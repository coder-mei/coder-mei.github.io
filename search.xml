<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[test]]></title>
    <url>%2F2019%2F03%2F14%2Ftest%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[安卓开发笔记：Fragment]]></title>
    <url>%2F2019%2F03%2F13%2F%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%9AFragment%2F</url>
    <content type="text"><![CDATA[一、概念什么是Fragment？ 中文翻译叫“碎片”。 Android3.0中引入了Fragment，其目的是在大屏设备上提供更好的用户体验。 我们可以把Fragment想成Activity中的模块，这个模块有自己的布局，有自己的生命周期。 在Activity运行的时候，可以加载或移除Fragment。 和Activity的关系Fragment不能脱离Activity。一个Activity可以包含多个Fragment。一个Fragment也可以被多个Activity使用。 二、Fragment写法一个Fragment也是一个类，该类要继承android.app.Fragment。Fragment类中重写onCreateView方法，该方法中加载Fragment的布局文件(.xml)。 三、Activity中添加Fragment静态添加是把Fragment作为一个控件，添加到布局文件中。Activity布局文件中添加标签,关联Fragment类。 123456789101112131415161718192021&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;!--添加两个Fragment--&gt; &lt;fragment android:id="@+id/left_fragment" android:layout_width="0dp" android:layout_height="match_parent" class="com.example.coder_mei.fragmentdemo.LeftFragment" android:layout_weight="1"/&gt; &lt;fragment android:id="@+id/right_fragment" android:layout_width="0dp" android:layout_height="match_parent" class="com.example.coder_mei.fragmentdemo.RightFragment" android:layout_weight="2"/&gt;&lt;/LinearLayout&gt; 动态添加通过java代码添加到Activity中。步骤： Activity布局文件中添加标签（其他布局标签也可以，推荐使用）。 在Activity中onCreate方法中关联Fragment。 xml代码 12345678910111213141516171819&lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" android:orientation="horizontal" android:layout_width="match_parent" android:layout_height="match_parent"&gt; &lt;!--添加两个Fragment--&gt; &lt;FrameLayout android:id="@+id/left_frame_layout" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="1"/&gt; &lt;FrameLayout android:id="@+id/right_frame_layout" android:layout_width="0dp" android:layout_height="match_parent" android:layout_weight="2"/&gt;&lt;/LinearLayout&gt; java代码 1234567891011121314151617 @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_second);// FragmentManager是Activity与Fragment之间进行交互的接口。 FragmentManager fragmentManager = getFragmentManager(); FragmentTransaction transaction = fragmentManager.beginTransaction(); LeftFragment leftFragment = new LeftFragment(); transaction.add(R.id.left_frame_layout, leftFragment); RightFragment rightFragment = new RightFragment(); transaction.add(R.id.right_frame_layout, rightFragment); transaction.commit(); &#125; 四、Fragment三种状态 状态 概念 运行状态(Active/Running) Fragment处于可见、且与它关联的Activity处于运行状态。 暂停状态(Paused) Activity处于暂停状态时、与它相关联的可见Fragment会进入暂停状态。 停止状态(Stopped) Activity处于停止状态时、与它相关联的Fragment会进入停止状态。或者调用remove()、replace()方法将碎片从活动中移除、且调用addToBackStack()。 五、Fragment生命周期每个Fragment都有自己的生命周期，虽然Fragment有自己的生命周期，但因为Fragment必须嵌入到Activity中使用，因此Fragment的生命周期受Activity的生命周期所控制。 当Activity暂停时，该Activity内的所有Fragment都暂停。 当Activity被销毁时，该Activity内的所有Fragment都会被销毁。 十一个生命周期方法 作用 onAttach() 挂载，将Fragment挂载到Activity中。 onCreate() 创建Fragment。 onCreateView() 创建视图，主要用于创建Fragment自身的UI，返回值是自身UI对应的View。 onActivityCreated() 当Activity的onCreate方法执行完毕后，告诉Fragment自己创建完毕。此时，Fragment就用onActivityCreated用来接收Activity传递过来的信息 onStart() 让Fragment可见。 onResume() 让Fragment可交互。 onPause() 让Fragment不可交互。 onStop() 让Fragment不可见。 onDestroyView() 销毁视图。 onDestroy() 销毁Fragment。 onDetach() 解除挂载，Activity要销毁了，就要从Activity中移除Fragment。 过程1、2过程1、2是一个Fragment的创建与销毁的过程，与Activity的创建销毁相似（参照上一篇微博 安卓开发学习笔记：Activity）。差异在于，Fragment要比Activity少一个Restart生命周期方法。多出五个生命周期方法，分别是： onAttach、onDettach挂载和解除挂载。 onCreateView、onDestroyView创建和销毁视图。 onActivityCreated确保与Fragment相关联的Activity已经创建完毕。 过程3（前提：First Fragment被放入回退栈中，即代码中调用addToBackStack()方法。）点击replace second fragment按钮，打开Second Fragment，此时会调用First Fragment的onPause、onStop、onDestroyView生命周期方法。再点击回退按钮，会调用First Fragment里的onCreateView、onActivityCreated、onStart、onResume方法。 旋转屏幕，Fragment的生命周期方法为什么会被重复调用？ 当我们旋转屏幕时，Activity会被销毁并重新创建，并且在销毁之前执行onSaveInstanceState方法。这个方法会保存Activity的一些信息，其中就包括添加过的Fragment，当Activity被重新创建时，会初始化其中的变量。在Activity中的onCreate方法中有创建Fragment的过程，所以执行onCreate时也会重新创建一个Fragment。导致重叠。 解决方案一：不让Activity保存信息。 1234 @Override protected void onSaveInstanceState(Bundle outState) &#123; // super.onSaveInstanceState(outState); &#125; 解决方案二：不让Activity走生命周期方法。 1android:configChanges="keyboardHidden|screenSize|orientation" 解决方案三：在onCreate中判断Bundle数据是否为空，为空则创建Fragment，不为空则不创建。 六、传递数据Activity传递数据给Fragment: 使用Bundle、setArguments传递数据。Activity里创建要传递的数据 12345678910//创建bundle，将要传递的键值对儿绑定到bundle里。Bundle bundle = new Bundle();bundle.putString("key", passValue);DemoFragment fragment = new DemoFragment();//将bundle通过setArguments方法绑定到Fragment里。fragment.setArguments(bundle);transaction.add(R.id.fragment_frame_layout, fragment);transaction.commit(); Fragment里接收数据 123//通过getArguments获取bundle。Bundle bundle = getArguments();String receiveValue = bundle.getString("key"); 获取已创建的Fragment对象，直接传递。Activity里 12//在frame layout与Fragment类关联时，创建一个Tag，Tag是Fragment的唯一标识。transaction.add(R.id.second_fragment_frame_layout, secondFragment, "SECOND_FRAGMENT"); Fragment里 12//通过Tag找到Fragment，还可以使用findFragmentByIdSecondFragment secondFragment = (SecondFragment) fragmentManager.findFragmentByTag("SECOND_FRAGMENT"); 七、Fragment常用的方法android.app.Fragment：主要用于定义Fragmentandroid.app.FragmentManager：主要用于在Activity中操作Fragmentandroid.app.FragmentTransaction：保证一些列Fragment操作的原子性 常用方法 用法 getFragmentManager() 获取FragmentManager transaction.add() 向Activity中添加一个Fragment transaction.remove() 从Activity中移除一个Fragment，如果被移除的Fragment没有添加到回退栈，则这个Fragment实例将会被消除 transaction.replace() 替换成另一个Fragment transaction.hide() 隐藏当前Fragment，仅仅是设为不可见，并不会销毁。使用场景：如果不希望视图被重绘，则使用hide和show。 transaction.show() 显示之前隐藏的Fragment transaction.commit() 提交一个事务 transaction.addToBackStack() 添加一个Fragment事务到回退栈 八、Fragment其他作用作为数据恢复用：Activity旋转时，如果是少量数据，可以使用onSaveInstanceState和onRestorInstanceState。如果是大量数据，可以使用没有布局的Fragment保持需要恢复的对象。]]></content>
      <categories>
        <category>安卓</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[安卓开发笔记：Activity]]></title>
    <url>%2F2019%2F03%2F12%2F%E5%AE%89%E5%8D%93%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0%EF%BC%9AActivity%2F</url>
    <content type="text"><![CDATA[一、概念Activity是与用户交互的接口。是四大组件之一。它是一个容器，不绘制任何东西，只负责组织将要被绘制的组件。通俗地讲就是用户界面。 二、Activity写法一个Activity是一个类，该类要继承android.app.Activity。 三、Activity启动基本流程 启动一个app时，Android操作系统会读取AndroidManifest.xml文件，来确定运行哪个Activity。 找到Activity后会生成Activity，然后调用该Activity的onCreate()方法。 在onCreate()方法中读取布局文件（setContentView(R.layout.布局文件名);），来确定显示什么样的内容。 四、Activity三种状态 状态 概念 例子 运行状态(Active/Running) Activity处于可见、且可与之交互的状态。 Activity被启动。 暂停状态(Paused) Activity处于半透明、且不能与之交互的状态。 Activity里弹出了一个dialog，此Activity显示在dialog后面以半透明的形式存在。 停止状态(Stopped) 一个Activity被另一个Activity完全覆盖。 Activity启动另一个Activity，此Activity被另一个Activity完全遮住。 五、Activity生命周期 七个生命周期方法 作用 onCreate() 表示Activity正在被创建，这是生命周期中的第一个方法。这个方法中可以做一些初始化的工作。如调用setContentView去加载界面布局资源，初始化Activity所需数据等。 onStart() 表示Activity正在被启动，这时Activity已经可见了，但还未出现在前台，无法与之交互。 onResume() 表示Activity已经可见了，并且出现在前台并可与之交互。 onPause() 表示Activity正在停止，可以做一些存储数据，停止动画等工作。 onStop() 表示Activity即将停止，可以做一些稍微重量级的回收工作。 onRestart() 表示Activity重新启动，从不可见状态转为可见状态时会被调用。 onDestroy() 表示即将被销毁，生命周期的最后一个方法。可以做回收工作和最终的资源释放。 正常情况的生命周期（1到6） 过程1（onCreate()、onStart()、onResume()）启动app，此时调用onCreate()、onStart()、onResume()，第一个Activity就处于运行状态。 过程2（onPause()）启动第二个Activity，第一个Activity处于暂停状态。调用onPause() 过程3（onStop()）启动第三个Activity，此时第一个Activity处于停止状态。调用第一个Activity的onStop()。 过程4（onDestroy()）点击退出按钮，退出app。调用onDestroy()来销毁Activity。 过程5（onResume()）从第二个Activity回退到第一个Activity。调用onResume()。 过程6（onRestart()、onStart()）从第三个Activity回退到第二个Activity，onRestart()、onStart()；再回退到第一个Activity。调用onResume()。 小结 综上现象、调用onResume()后、Activity处于运行状态(可见、可交互)；调用onPause()后、Activity处于暂停状态(可见、不可交互)；调用onStop()后、Activity处于停止状态(不可见、不可交互)；调用onDestroy()后、Activity被销毁。 从整个生命来说、onCreate()和onDestroy()是一对儿、表示Activity的创建和销毁。onStart()和onStop()是一对儿、表示Activity是否可见。onResum()和onPause()是一对儿、表示Activity是否可交互。 状态交互图 异常情况的生命周期（7、8）当优先级高的Activity需要内存时，系统会销毁优先级较低的Activity(可能是暂停状态（走过程7）、可能是停止状态（走过程8）的Activity)。当用户再次使用该Activity时，会重新创建它。 Activity优先级 Activity状态 高 运行状态 中 暂停状态 低 停止状态 六、启动Activity从FirstActivity跳转到SecondActivity： 12Intent intent = new Intent(FirstActivity.this, SecondActivity.class);startActivity(intent); 七、任务栈（back stack） Android系统是通过任务栈来管理Activity的。 当一个Activity启动时，会把它压入到该任务栈中。 当用户按返回键、或者结束掉该Activity时，它会从该任务栈中弹出。 先进后出的原则 除了点击退出按钮退出任务栈外，还可以通过finish()方法来结束Activity。例1：设置一个关闭按钮，在监听事件中调用finish()方法。则此按钮可以关闭当前Activity例2：在第二个Activity的onStop()方法中调用finish()方法。则，启动第三个Activity时，第二个Activity会退出任务栈中（如下图）。 八、启动模式方式一（静态）在AndroidManifest.xml的Activity标签中设置启动模式例：android:launchMode=”singleTask” 启动模式 概念 standard(默认) 使用这种启动模式启动Activity时，每次都会创建一个新的实例放进任务栈中。 singleTop 检测栈顶是不是要启动的Activity，如果是，则不创建新的实例；如果不是，则创建新的Activity。 singleTask 检测整个任务栈中是否存在Activity，如果存在则置于栈顶，并将该Activity以上的Activity都销毁。 singleInstance singleInstance的Activity会出现一个新的任务栈中，而且该任务栈只存在一个Activity。 备注：黑箭头表示打开Activity，蓝箭头表示退出 standard例 singleTop例 singleTask例 singleInstance例 方式二（动态）使用intent flag启动Activity：intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); Intent flag 概念 FLAG_ACTIVITY_SINGLE_TOP 与singleTop效果相同 FLAG_ACTIVITY_CLEAR_TOP 与singleTask效果相同 FLAG_ACTIVITY_NEW_TASK 使用一个新的任务栈来启动Activity FLAG_ACTIVITY_NO_HISTORY 使用这种模式启动Activity，当该Activity启动其他的Activity后，该Activity就会消失，不会保留在栈中。如1st-&gt;2nd，2nd以这种模式启动3rd，3rd-&gt;4th，则当前栈为1st-&gt;2nd-&gt;4th，不存在第三个Activity 九、Activity传递数据12345678910//第一个Activity中创建一个intent，用intent封装要传递的数据。Intent intent = new Intent(FirstActivity.this, SecondActivity.class);intent.putExtra("KEY_NAME","abc");Intent intent = new Intent(FirstActivity.this, SecondActivity.class);startActivity(intent); //第二个Activity中获取intent，然后获取intent中封装的数据。Intent intent = getIntent();String value = intent.getStringExtra("KEY_NAME"); Log.d(ACTIVITY_LIFECYCLE, String value = intent.getStringExtra("KEY_NAME"); 十、AndroidManifest.xml里配置Activity123456789101112131415161718192021222324&lt;!--name:包名+类名，也可以写成 name=".FirstActivity" --&gt;&lt;!--configChanges:屏幕旋转是不会重新执行onCreate方法，而是调用onConfigurationChanged，这个属性经常用--&gt;&lt;activity android:name="com.example.qmpc_146.activitylifecycle.FirstActivity"android:configChanges="keyboardHidden|screenSize|orientation"&gt;&lt;!---app启动哪个activity主要取决于Intent-filter中的action数据类型，类型为.MAIN表示该程序的入口Activity,每个Activity都可以有intent-filter--&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.MAIN" /&gt; &lt;category android:name="android.intent.category.LAUNCHER" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt;&lt;!---第二个Activity，每个Activity都必须在AndroidManifest.xml里注册--&gt;&lt;!---该Activity以dialog形式显示--&gt;&lt;!---显示在Activity左上角的名称--&gt;&lt;!---禁止旋转，保持屏幕始终是竖屏--&gt;&lt;activity android:name=".SecondActivity" android:theme="@android:style/Theme.Dialog" android:label="my activity dialog" android:screenOrientation="landscape" &gt;&lt;/activity&gt; &lt;!---第三个Activity--&gt; &lt;activity android:name=".ThirdActivity"/&gt; 十一、几个Activity的方法说明 常用方法 用法 startActivity 启动Activity finish() 关闭Activity onSaveInstanceState(Bundle outState, PersistableBundle outPersistentState) 在onStop之前一定会被调用，用来保存瞬时数据 onRestoreInstanceState(Bundle savedInstanceState, PersistableBundle persistentState) 恢复瞬时数据 startActivityForResult(Intent intent, int requestCode) 启动Activity并请求其返回结果 setResult (int resultCode, Intent data) 设置返回结果 onActivityResult(int requestCode, int resultCode, Intent data) 结果返回]]></content>
      <categories>
        <category>安卓</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书进度]]></title>
    <url>%2F2019%2F03%2F12%2F%E8%AF%BB%E4%B9%A6%E8%BF%9B%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[coder梅：读书进度git和github 书名 进度 总结 最后阅读时间 尚硅谷 Git&amp;Github 100% 共62节 可作为字典复看，内容很精炼 2019/3/11 设计模式 书名 进度 总结 最后阅读时间 《大话设计模式》程杰 著 第26章 每章的加粗字体可复看 2019/3/6 安卓书籍 书名 进度 总结 最后阅读时间 《android studio实战 快速、高效地构建android应用》 Adam Gerber 著 靳晓辉 译 1、2、3、4章 第2、3、4章不错：讲android studio常用技巧，很实用，可复读。 2019/1/24 《Android编程权威指南》 Bill Phillips Chris Stewart Kristin Marsicano著 王明发 译 9、10章 可复读 2018/4/9 《Android群英传》 徐宜生 著 第1、2章 可复读：第1章 2019/2/21 安卓视频 书名 进度 总结 最后阅读时间 geek视频 3阶段：1.0-4、1.14、2.16-20、5.45、4.2-4、4.14-15、4阶段：8 无需复看 2019/2/15 mars视频 1季完、重置版1季完、第2季：1、3 无需复看 2019/2/20 阳光沙滩Activity视频教程 1-3、6-12、18-25 无需复看 2018/4/20 育知同创视频 59-66 无需复看 2018/4/24 产品书籍 书名 进度 总结 最后阅读时间 《人人都是产品经理》 苏杰 著 42页 可复读 2019/3/1 人工智能视频 书名 进度 总结 最后阅读时间 万门大学 你知道的人工智能 你不知道的python 100% 共7节 无需复看 2019/2/21 万门大学 深度学习和神经网络 1.1-16 共9节 大部分内容看不懂、但无需复看 2019/2/27 万门大学 让神经网络听懂故事 1.1-5 共11节 - 2019/3/6 系统分析师 书名 进度 总结 最后阅读时间 希赛 系统分析师 1-2 共10节 - 2019/3/7]]></content>
      <categories>
        <category>计划</category>
      </categories>
      <tags>
        <tag>schedule</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F12%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
